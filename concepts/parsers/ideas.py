from types import SimpleNamespace

namespace = SimpleNamespace()
namespace.recursion = namespace
namespace.f = (
    lambda n: 1
    if n <= 2
    else n * namespace.recursion.recursion.recursion.recursion.f(n - 1)
)
print(namespace.f(5))


# Option 1: declarative using method binding
word = Parser()
arg = Parser()
args = Parser()
word.parse_rule = letter.repeat()
args.parse_rule = arg.repeat()
word.postprocessing = lambda i, j, word: Word(i, word)


# Option 2: Victor's combinators, since they are not that bad
word = Parser()
arg = Parser()
args = Parser()
word.update(letter.repeat().map(lambda i, j, word: Word(i, word)))
args.update(arg.repeat())


# Option 3: Cool varname interpretation
@parser
def parse_word(i, j, letter_repeated):
    return "".join(letter for letter, _ in letter_repeated)


parse_args = parser(
    lambda i, j, left_parenth, arg_repeated, righ_parenth: tuple(arg_repeated)
)


# Option 4: Domain specific language
parse_word = parser("word*", lambda i, j, word: word)
parse_function = parser(
    'name "(" arg* ")"', lambda i, j, name, _, args, _2: (name, args)
)


# Option 5: EBNF at the begining of the file and specific structure of parsers
# name = ?...?
# arg = ?...?
# function = name "(" arg* ")"
def parse_function(source, i):
    ...  # <-- code generated by parser generator
    if source[j] != ")":
        return None
    # blank line to split generated code and my code
    return Function(i, name, args)


# Option 6: EBNF at the begining of the file and specific structure of parsers
# name = ?...?
# arg = ?...?
# function = name "(" arg* ")"
def parse_function(i, j, name, args):
    return Function(i, name, args)


# generated code
def parse_function(source, i=0, postprocessing=parse_function):
    ...
    return postprocessing(i, j, name, args)


# Option 7: separate EBNF and the actions
def parse_function(source, i=0):
    parsed = parse_name(source, i)
    if not parsed:
        return None
    i, j, result = parsed  # <-- generated code
    return i, j, assemble_function(i, j, result)  # <-- call of user function
